import{_ as e,c as o,o as l,a4 as a}from"./chunks/framework.i35rQw0I.js";const m=JSON.parse('{"title":"垃圾回收机制（Garbage Collection）","description":"","frontmatter":{},"headers":[],"relativePath":"column/ClassJS/GC.md","filePath":"column/ClassJS/GC.md"}'),t={name:"column/ClassJS/GC.md"},i=a('<h1 id="垃圾回收机制-garbage-collection" tabindex="-1">垃圾回收机制（Garbage Collection） <a class="header-anchor" href="#垃圾回收机制-garbage-collection" aria-label="Permalink to &quot;垃圾回收机制（Garbage Collection）&quot;">​</a></h1><blockquote><p>定期扫描内存中搞得对象，标记可达对象和不可达对象，对于不可达对象（即不再引用的对象），将其从内存中清除以释放内存</p></blockquote><ol><li><p>标记清除（Mark-and-Sweep）- 主流</p><blockquote><p>垃圾回收器会定期扫描内存中的对象，从根对象开始遍历内存中的所有对象，对于可达对象，通过标记它们来标识它们是可达对象；对于未被标记的对象，就说明它们是不可达对象，需要被清除。该算法的优点是可以处理循环引用的情况，但在执行时间上可能会比较长，影响程序的性能。 主要步骤</p><ol><li>创建一个根对象，例如 window 对象</li><li>遍历根对象及其所有引用的对象，并标记它们是可达对象；</li><li>遍历内存中所有对象，如果发现某个对象未被标记，就将其清除。</li></ol></blockquote></li><li><p>引用计数（Reference Counting）</p><blockquote><p>垃圾回收器会记录每个对象被引用的次数，当对象被引用的次数为 0 时，就将该对象清除。该算法的优点是实现较为简单，但无法处理循环引用的情况，可能会导致内存泄漏。 主要步骤</p><ol><li>给每个对象添加一个引用计数器，初始值为 0；</li><li>当对象被引用时，引用计数器加 1；</li><li>当引用计数器为 0 时，就将该对象清除。</li></ol></blockquote></li></ol>',3),c=[i];function n(r,s,_,p,d,u){return l(),o("div",null,c)}const C=e(t,[["render",n]]);export{m as __pageData,C as default};
